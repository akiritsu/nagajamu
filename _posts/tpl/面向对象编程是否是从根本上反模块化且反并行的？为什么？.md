---
layout: post
title: OO是否是反模块化反并行的
---

* content
{:toc}



作者：vczh
链接：https://www.zhihu.com/question/19728806/answer/18558397
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

说实话，用面向对象的手法来写并发程序真的是难爆了。我最近在www.gaclib.net里面添加一个“从EBNF自动生成智能提示”的算法（写得差不多了，代码一直在http://gac.codeplex.com 上更新），就遇到了这个问题。

我们都知道，唯一可以给UI建模建的好用起来又爽的也就只有面向对象了，但是写智能提示又怎能不并发呢，于是我只好把OO和Actor这两种风格在C++里面混合了起来。幸好OO是鼓吹封装的，于是我把那些不需要给别人操作的Actor们也装在了另一个大类里面，用户只需要单线程的操作这个类就可以了。多线程的部分就在这个类的内部。

于是当你操作不当的时候，不可避免的会遇到racing condition。什么是racing condition呢？就是多个函数同时运行之后的结果，跟他们挨个运行之后的结果不一样。你可以想象一下我同时对一个变量+1两次，如果你加的方法不对，有时候就会发生racing condition——结果只加了1，不是2。

于是你就会慢慢明白OO跟并发到底抵触在哪了。防止racing condition，写出一个正确的并发程序，是需要你小心翼翼（对大部分流行语言都有是，除了Haskell）的处理一些状态变量，而OO却是希望你通过释放接口来阻止你对状态变量的认识（嗯，@王垠 说得对，面向对象他妈就是个祸害。而且祸害就算了，面向对象本来应该用interface oriented programming（认真学习COM就会得到这一点，但是这里的interface并不一定需要是语法上的interface。所以说很多不学无术的人除了喷COM难用以外根本没办法从她身上学到任何东西，这些程序员都是a piece of shit）来做，结果那帮人竟然鼓吹什么is-a啊，has-a这些伤天害理的知识，绝对是计算机科学教育的第一大祸害）。于是你现在开始写代码的时候就会遇到这个问题了：
这个类的这个方法到底能不能并发呢？
呵呵，如果没有文档，也没有源代码，你永远也回答不出这个问题。

这是不是意味着我们必须把每一个method都做成线程安全的呢？这当然不是，线程安全是会损耗性能的，而且不能忽视。那是不是为了性能就全部都做成线程不安全的呢？当然也不是，正确性永远都是第一位的。那到底要怎么做呢？
当你用OO和并发一起做的时候，你除了付出痛苦来单独思考每一个method是不是需要做成线程安全以外，没有任何指导方法或者科学依据来减轻你的负担。

当然对于工程师来讲，只要公司多给点钱，那我们自然可以把程序写得更好，于是这点小问题还是无所谓的。但是对于那帮做学术的人来讲，那就不一样了。他们眼中只有行跟不行，于是自然就说出这句话了。

不过我认为这句话说的也是有道理的，我并不是在说他们说的不对，我是在同意他们。OO和并行你想做的好，除了看Jeffrey Richter的书以外，没有任何办法。但是我们知道，很多懒惰的人根本连教程都不愿意仔细看，怎么会学到正确的并发程序的设计方法呢？

\
编程语言本质上来说是为了程序员服务而不是机器，首要是让程序员正确描述出逻辑，次要的是让机器能比较容易执行。一般程序员会觉得OO比FP更容易理解。
应用程序可以有不同的层次，底层封闭细节之后完全可以体现出另一种模式，比如一段面向对象的程序对外只暴露一个纯函数接口，所有对象的构造和析构都在这个函数中完成，这也没有什么不可以的。并不存在所有逻辑都要用一种方法来写否则就怎么怎么样这种事，机器是死的人是活的，应该靠主观能动性来保证代码质量，而不是死框框。

作者：灵剑
链接：https://www.zhihu.com/question/19728806/answer/225069022
来源：知乎
著作权归作者所有，转载请联系作者获得授权。
