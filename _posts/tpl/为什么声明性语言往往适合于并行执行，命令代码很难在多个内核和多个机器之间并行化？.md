---
layout: post
title: 为什么声明式语言适合于并行执行
---

* content
{:toc}






作者：阿莱克西斯
链接：https://zhuanlan.zhihu.com/p/34191158
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

目录：

序
声明式范式和副作用
容错，状态, 分布式共识, FLP Impossibility和Paxos
时间线和系统设计
范式和分布式系统
尾




序

声明性范式只要求程序员提供程序的目的，然后系统(广义)自己有编译器,lib或优化器去计算出"怎么达到目的"最好的执行路径，而不用程序员提供怎么达到目的方法或者hint。而命令式范式需要程序员手把手的告诉机器怎么完成任务。机器无法区分目的和手段，而必须严格按照程序指定的来执行，所以即使系统有更好的执行算法，在命令式范式里，机器也必须老老实实的严格按照指定的步骤来执行命令。


相比之下，差别就是根据“优化器”计算出来的执行路径好，还是人指定的好呢？（把“好”定义为价值除以产生价值需要的时间）
举个例子： 对SQL来说，你只需要指定你想找什么。数据库会自己算出来怎么按照你的要求找。 你如果用java或C在一大块硬盘上找数据，你就要自己去指定机器每一步怎么运行才能给你结果。



声明式范式和副作用

声明性范式提倡消除“副作用”(Side Effect)，状态(state)是分布式系统中影响很大的一个概念，所以我们着重讨论状态这个副作用。

命令式范式解决问题的方式：把问题分成A，B两个进程，然后A把状态写在S1这里，然后去blablabla，B读到S1之前A写的状态，如果是x怎么怎么样，如果是y怎么怎么样。。。
声明式范式解决问题的方式：问题的定义就是这样，你要几个进程你随便，你怎么完成任务你随便，你需要内部维护几个状态你随便(只要别影响他人,或者说别人观察不到)，把问题给我解决了。
所以你可以看到对终端用户来说，声明式范式不需要用户指定状态，和执行路径。这给了系统“优化器”无限的操作空间。



容错，状态, 分布式共识, FLP Impossibility和Paxos

分布式环境中，最重要的一点就是容错，特别是对Partial failure的容错，比如一个1000个节点的机群，中间一台机器突然挂了或者网络出问题了，整个机群组成的算法无法工作，这是不可接受的。
在分布式环境下，维护一个全局状态可以看作一个共识(consensus)问题；我们目前最流行的share nothing的网络构架(就是机器的连接通信就靠一根网线，不share硬盘内存), 呈现出一种异步通信模型的抽象模型。所以我们要维护一个全局状态，就需要在异步通信模型中，解决共识问题。
FLP Impossibility在理论和学术上证明了在异步通信模型中，在一个机群里，非fault的机器的共识是无法在哪怕一台未知机器出问题的情况下达到的。也就是说不存在一种算法，可以保证异步模型中的共识。FLP impossibility提出了一个“算法”，使得对任意的共识算法，它总能找出系统的中关键的某节点，fail掉它使算法失败。所以任意共识算法只能“恰巧”成功，而不能保证成功。

神仙Lamport在没有推翻FLP Impossibility的情况下，提供了一个可以在工业应用上达到共识的算法，就是Paxos；但是很复杂，且Paxos也不能保证系统的liveness。

总之：全局状态同步是一个非常复杂的问题，且依赖全局状态的算法对系统的吞吐量影响很大，请往下看。

（对分布式理论有兴趣的同学可以专注专栏：用谁都能看懂的方法解释分布式系统，不过目前还没有文章，也不保证什么时候有文章。。。。 求不打）





时间线和系统设计

考虑系统所有需要的action, 系统并行化的关键点在于

action发生的因果关系(causality), 比如你的算法设计为，A set状态S，B必须读到Aset的S的最新状态来采取决策。那么A的set action和B的决策action有因果联系。
action组成的的逻辑时间线
所有没有因果关系的action都可以安排在并行的时间线上，但是有因果关系的action必须安排在同一时间线上。很容易可以推理出，这时候得到的系统的多个时间线就是系统的理论上的最大可能并行度。

如何保证因果关系的action发生在一条时间线上呢？有2种方法

2个action安排在一台机器上串型执行
2个action安排在2台机器上，但是让2台机器通过通信保证先后关系。这可以看作是2台机器的共识问题。如果有多个action有因果关系则是经典共识问题。
很明显方法2很复杂，效率非常低。所以一个合理的并行运行设计，需要合理取舍方法1和方法2来安排系统的action的时间线，需要多少条时间线，什么时候合并逻辑时间线，什么时候开新的分支。





范式和分布式系统

到这里，我们可以看到设计一个正确的高性能分布式系统，需要：

我们清楚的了解我们的目标是什么
那些action可以组成一个合理的计算来达到我们的目标，这是问题的一个解。
如何合理安排我们的解中，所有action执行的时间线。
其实这时候结论已经很明显了，着力于副作用和状态消除的 声明式范式 只需要程序员负责1， 而留给了优化器无限的可能空间去找到 2和3的最优解。由于系统一般都会维护很多元数据和统计数据，类似于系统总共有多少节点，算力如何，内存分布如何，系统的数据分布如何。。。等等。都可以被优化器利用来动态的调整最优解。



而命令式范式就好比要程序员自己去指定机群如何运作去解决1，2，3；

两相比较，高下立判～

再举一个简单的例子：AWS Athena允许你在S3上用SQL分析多种数据。数据可能分布在成千上万的不同机器上。Athena决定用声明式的SQL就决定了用户不可能指定Athena如何运行。而如果Athena暴露的是一个图灵完备的类java用户接口，那么Athena就必须实现成接收用户的任何可能的“脑残”指令，比如用户指定我要有100个全局状态。。。。



即使离开分布式环境，从纯编程语言角度来讲，纯函数式的程序可以只考虑函数从input到output的mapping，而不在乎eval的顺序，把程序员从程序运行的时间序列里解放出来；从理论上来讲，有可能实现一个非常聪明的编译器来自动找到最好最快的执行顺序。而以状态为根本的命令式程序则会受到语句运行顺序的影响，因为哪个方法先跑哪个方法后跑会影响程序的运行结果，所以不仅使得编译器没有很多空间来优化执行路径，且程序员在推理程序行为的时候，必须要注意程序运行的顺序，才能推理出系统的正真行为是什么，如何改动之后，系统的新行为会变成什么样子。这都加重了程序员把程序写对的负担，增加了系统的复杂度。





尾

此作者目前处于

转变成分享干货
转变成 带逛/吸粉/吹区域块/开live/割韭菜
的叠加状态，关注需谨慎。

(以上信息为作者最后一丝人性留下的最后一条信息) ～
