#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
在大多数情况下，BBD通常指代降序二元决策图。（简称ROBBD，强调变量是降序排序的。） ——维基百科，自由的百科全书。（2007年7月7日）
\end_layout

\begin_layout Standard
7.1.4 二元决策图（Binary Decision Diagrams, BBD)
\end_layout

\begin_layout Standard
让我们现在研究这一重要的数据结构家族。计算机中，BDD已经快速成为重要的表示、操作布尔函数的方式之一。基础的点子是用分治法 (devide-and-conque
r scheme) 处理形如第6.3节提到的二分查找，但是引入了一些新东西。
\end_layout

\begin_layout Standard
Figure 21是一个简单的三元布尔函数，median (或者majority) 函数 <x1,x2,x3>的二元决策图。
\end_layout

\begin_layout Standard
我们可以这样理解：顶端的节点（node）为根节点（root）。下边的节点为分支节点（branch node）。每一个分支节点ⓙ，用一个代表变量的名称或者索引j=
v(ⓙ)标示。例如在Figure 21中，根节点①代表了x1。分支节点有两个后继（successors），用下降的直线连接。其中一条为虚线，成为LO；另外一条为
实现，成为HI。这些线组成的路径，构成了代表所有布尔变量取值的图。从根节点开始，当xj=0时，取节点ⓙ的LO分支；当xj=1时，取HI分支。最终，这条路径指向了
一个汇聚节点（sink node）。汇聚节点仅有两种：T代表TRUE，⊥代表FALSE。
\end_layout

\begin_layout Standard
在 Figure 2.1 中，可以非常明显地看出，当 { x1,x2,x3} 中至少两个变量为0时，函数值为FALSE。否则函数值为TRUE。
\end_layout

\begin_layout Standard
使用 0，1作为汇聚节点的人也很多。我们使用T和⊥，以减少0，1与分支节点⓪①的混淆。
\end_layout

\begin_layout Standard
在计算机中，Figure 21 会被表示为内存中的四个节点，每个节点有三个值域：V，LO，HI。V存储了变量的索引，LO和HI每个都指向了另外一个分支节点，或者
一个汇聚节点。 在字长为64-bit的字中，我们可以用8比特存储V，28比特存储LO，28比特存储HI。
\end_layout

\begin_layout Standard
这样的结构称为二元决策图（binary decision diagram），简称BDD。比较小的BDD可以画成实际的图，一张纸或者计算机的屏幕即可容纳。但是本质
上，每个BDD都是一个链接的节点的集合，所以称为二元决策有向无环图（binary decision dag）更为贴切——一个共享子树的二叉树，每个非汇聚节点都放
射出两条不同的线的有向无环图（directed acyclic graph）。
\end_layout

\begin_layout Standard
我们假设每个BDD都遵循两条重要的限制。第一，BDD必须有序（ordered）：即无论是LO还是HI，由ⓘ节点放射至ⓙ节点，必有i<j。这保证了在求值函数时，每
个变量xj都只被查询一次。第二，BDD必须是已约化的（reduced）：这意味着没有浪费空间。更确切地说，每个分支节点的LO和HI必须不等价，并且任意两个节点的
三个值域（V，LO，HI）不能全部相同。每个节点必须都可以从根节点出发访问。例如，下面两个图都不是BDD。第一个不是有序的，第二个不是已约化的。
\end_layout

\begin_layout Standard
现在，计算机工作者发明了大量的决策图变体。计算机科学文献中，有大量的缩略词如EVBDD，FBDD，IBDD，OBBD，OFDD，OKFDD，PBDD,
 …, ZDD。本书中，我们用BDD指代有序已约化的二元决策图，就像我们用tree指代有序平面图。这是因为在实际应用中，这样的BDD和tree是最泛用的。
\end_layout

\begin_layout Standard
回忆7.1.1节中的内容：每个布尔函数f(x1, ..., xn)与一个真值表（truth table）相关。该真值表是一个2n-bit的二进制串，以f(0,
 ..., 0)的值开始，依次表示f(0, ..., 0, 1), f(0, ..., 0, 1, 0), f(0, ..., 0, 1, 1), ..., f(1, ..., 1,
 1, 1)的值。例如，median函数<x1,x2,x3>的真值表为 00010111。这个真值表和（2）中所示的未约化（unreduced）的决策树的叶子节
点顺序相同，其中0代表⊥，1代表T。实际上，真值表和BDD有很大的关系，最好把他们理解成一类称为beads的二进制串。
\end_layout

\begin_layout Standard
一个n阶的真值表就是一个长为2n的二进制串。一个n阶的bead是一个不左右重复（not a square）的真值表β；也就是说，β不是形如αα的真值表，其中α是
任意长为2n-1的真值表。（数学家会把这样的bead称为长为2n的基元串。）0阶的bead有两个，0和1。1阶的bead有两个，01，10。当n>0时，n阶be
ad有22^n - 22^(n-1) 个，因为有个22^n 二进制串，其中22^(n-1)个为左右重复的。2阶的bead有： （去除了0000，0101，101
0，1111，译者注）。这些代表了所有依赖于x1取值的布尔函数f(x1,x2)。就意义而言，f(0,x2)不同于f(1,x2)。
\end_layout

\begin_layout Standard
每一个真值表τ都是一个不同的bead的幂（称为它的根）。这是因为如果τ长为2n且不是bead，那么它就是另外一个真值表τ′的square；通过减少τ的长度，对于
某些根β，必有τ′=βk。因此τ= β2k，且 β即是τ的根又是τ′的根（当然，k是2的幂）。
\end_layout

\begin_layout Standard
每个n阶的真值表τ (n>0)都有形如τ0τ1，其中τ0和τ1是n-1阶的真值表。很明显，τ代表了函数f(x1, ..., xn)，τ0代表了f(0,x2,
 ..., xn)，τ1代表了f(1,x2, ..., xn)。函数f(0,x2, ..., xn)和f(1,x2, ..., xn)被称为f的子函数。τ0τ1称为τ的子真值表。
\end_layout

\begin_layout Standard
子表的子表，仍被算为子表。表自身也是自己的子表。因此，对于任意0≤k≤n，一个n阶的真值表有2k个n-k阶的子表，这相关于(x1, ..., xn)的前k个变量的可能
取值组合。很多子表都有可能是完全相同的；在这种情况下，我们可以用一种压缩的形式（compressed form）描述τ。
\end_layout

\begin_layout Standard
一个布尔函数的beads是它的真值表的子表，且这些子表也为bead。例如，我们再次考虑median函数 <x1,x2,x3>，其真值表为00010111。这个函
数的子表集为：{00010111,0001,0111,00,01,11,0,1};其中除了00和11均为bead。因此 <x1,x2,x3>的bead集为：
\end_layout

\begin_layout Standard
现在我们获得了如下结论：布尔函数的BDD的节点与它的beads一一对应。例如，我们可以把每个节点的名称换为相应的bead，重绘Figure 21的图：
\end_layout

\begin_layout Standard
一般而言，一个函数的n+1-k阶真值表相关于该阶的子函数f(c1,...,ck-1,xk, ..., xn)；所以它的n+1-k阶beads相关于这些依赖xk值的子函数。因
此每个这样的bead都相关于一个
\end_layout

\end_body
\end_document
